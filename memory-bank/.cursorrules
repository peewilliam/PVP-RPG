# Regras e Convenções do Projeto MMORPG Topdown Isométrico

## Padrões de Comunicação

### Eventos de Rede
- Todos os eventos utilizam o formato `categoria:ação` (ex: `player:move`, `monster:spawn`)
- Eventos são definidos no arquivo `shared/constants/gameConstants.js`
- Fluxo de comunicação segue o padrão "cliente envia comando, servidor processa e retorna estado"

### Fluxo de Sincronização de Jogadores
1. **Conexão Inicial**: Servidor envia ID único via `player:init`
2. **Notificação de Novos Jogadores**: Servidor notifica todos via `player:joined`
3. **Sincronização de Jogadores Existentes**: Servidor envia informações via `player:existing`
4. **Comandos de Movimento**:
   - Cliente envia comandos (não posições) via `player:move`
   - Servidor atualiza posição, calcula rotação e notifica todos via `player:moved`
5. **Desconexão**: Servidor notifica todos via `player:disconnected`

## Padrões de Arquitetura

### MCP (Model-Controller-Presenter)
- **Model**: No servidor, contém toda a lógica de jogo e o estado das entidades
- **Controller**: No servidor, interpreta inputs e orquestra lógica de alto nível
- **Presenter**: No cliente, responsável apenas pela renderização e inputs

### Regra de Servidor Autoritativo
- O servidor é a única fonte de verdade para o estado do jogo
- O cliente envia apenas intenções/comandos, nunca posições finais
- Toda lógica de jogo, colisão e validação acontece no servidor

## Convenções de Código

### Estrutura de Arquivos
- `/client`: Todo código do lado do cliente
- `/server`: Todo código do lado do servidor
- `/shared`: Código e constantes compartilhadas

### Padrões de Robustez
- Sempre validar dados recebidos antes de processá-los
- Utilizar try/catch para lidar com exceções em funções críticas
- Tratar erros de forma explícita para evitar crashes
- Validar valores numéricos para evitar NaN

### Tratamento de Eventos Assíncronos
- Todos os handlers de eventos do geckos.io devem ser tratados com try/catch
- Logs de erro devem ser descritivos para facilitar depuração

## Padrões de Implementação

### Renderização com Three.js
- Câmera isométrica usando OrthographicCamera
- Objetos temporários são representados como cubos coloridos
- A câmera segue o jogador mantendo vista isométrica

### Movimento
- Movimento baseado em velocidade e não em posições absolutas
- Velocidade padrão definida em PLAYER.SPEED
- Inputs são processados a cada frame, mas posições são atualizadas pelo servidor
- Movimentação é relativa à orientação da câmera isométrica:
  - W (para frente): move na direção (x-1, z-1)
  - S (para trás): move na direção (x+1, z+1)
  - A (para esquerda): move na direção (x-1, z+1)
  - D (para direita): move na direção (x+1, z-1)

### Rotação
- Rotação do personagem é calculada pelo servidor com base na direção do movimento
- A direção de movimento determina o ângulo de rotação em incrementos de 45 graus (8 direções)
- Em visão isométrica, os ângulos de rotação são ajustados para corresponder visualmente à direção do movimento:
  - W (frente): rotação para diagonal superior-direita (1.75π radianos) - Noroeste
  - S (trás): rotação para diagonal inferior-esquerda (0.75π radianos) - Sudeste
  - A (esquerda): rotação para diagonal superior-esquerda (1.25π radianos) - Sudoeste
  - D (direita): rotação para diagonal inferior-direita (0.25π radianos) - Nordeste
  - W+D: rotação para cima (0 radianos) - Norte
  - W+A: rotação para esquerda (1.5π radianos) - Oeste
  - S+D: rotação para direita (0.5π radianos) - Leste
  - S+A: rotação para baixo (1.0π radianos) - Sul
- O servidor envia a rotação calculada junto com a atualização de posição
- O mouse será usado apenas para apontar habilidades, não para rotacionar o personagem

### Sincronização de Estado
- O loop do servidor roda a 20 ticks por segundo (50ms)
- Atualizações de estado são enviadas apenas quando houver mudanças 